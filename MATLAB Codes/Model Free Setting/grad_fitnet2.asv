function dYl = grad_fitnet2(net, X, J, Y, Y_l, l)
% Outputs:
%   y   : [M x 1] network outputs at each (X(i,:), J(i), Y)
%   dYl : [M x N] per-sample gradient ∂y_i/∂Y(l,:) in ORIGINAL (unprocessed) Y space

    [M, N] = size(X);
    K      = size(Y,1);
    
    Y(l,:) = Y_l;

    % --- Extract layer chain
    L  = numel(net.layers);
    W  = cell(L,1); b = cell(L,1); tf = cell(L,1);
    W{1} = net.IW{1,1};          b{1} = net.b{1};          tf{1} = net.layers{1}.transferFcn;
    for t = 2:L
        W{t} = net.LW{t,t-1};    b{t} = net.b{t};          tf{t} = net.layers{t}.transferFcn;
    end

    % --- Input partitions
    Din_x  = N; Din_1h = K; Din_Y = K*N;
    y_start = Din_x + Din_1h + 1;         % start of Y(:) in input vector
    y_end   = y_start + Din_Y - 1;
    idxYl   = (l : K : K*N).';            % column-major positions for row l

    % --- Access processing settings of input #1
    fcns = net.inputs{1}.processFcns;                % e.g., {'removeconstantrows','mapminmax'}
    PS   = net.inputs{1}.processSettings;            % cell array, same length as fcns

    y   = zeros(M,1);
    dYl = zeros(M,N);

    Yvec = Y(:);                                     % unprocessed Y flattened

    for i = 1:M
        j = J(i);
        % Build UNPROCESSED input u
        onehot = zeros(K,1); onehot(j) = 1;
        u = [X(i,:).'; onehot; Yvec];                % [Din x 1] UNPROCESSED

        % ---- Apply SAME processing as net to get z (processed input)
        [z, Jproc] = apply_input_processing(u, fcns, PS);

        % ---- Forward (processed space): a0=z, then chain
        a = cell(L+1,1); n = cell(L,1); a{1} = z;
        for t = 1:L
            n{t}   = W{t}*a{t} + b{t};
            a{t+1} = local_act(tf{t}, n{t});
        end
        y(i) = a{L+1};

        % ---- Backprop in processed space: ∂y/∂z
        s = cell(L,1);
        s{L} = local_act_deriv(tf{L}, n{L}, a{L+1});
        for t = L-1:-1:1
            s{t} = (W{t+1}.' * s{t+1}) .* local_act_deriv(tf{t}, n{t}, a{t+1});
        end
        gy_z = W{1}.' * s{1};                         % ∂y/∂z (processed input)

        % ---- Chain back to UNPROCESSED input: ∂y/∂u = Jproc' * (∂y/∂z)
        gy_u = Jproc.' * gy_z;                        % [Din x 1] unprocessed

        % ---- Slice Y and pick row-l entries
        gY_full = gy_u(y_start:y_end);                % [K*N x 1]
        dYl(i,:) = (gY_full(idxYl)).';                % [1 x N]
    end
    
end

function [z, Jproc] = apply_input_processing(u, fcns, PS)
% Apply net.inputs{1}.processFcns in-order to u, and build total Jacobian wrt u.
% Currently supports 'mapminmax' exactly; other common fcns are no-ops for Jacobian here.

    z = u;                             % start with unprocessed
    Jproc = speye(numel(u));           % accumulate Jacobian (sparse diag)

    for k = 1:numel(fcns)
        f = fcns{k};
        S = PS{k};

        switch lower(f)
            case 'mapminmax'
                % z = (z - xoffset).*gain + ymin
                z = (z - S.xoffset) .* S.gain + S.ymin;
                % Jacobian is diag(gain)
                G = diag(S.gain);
                Jproc = G * Jproc;

            case 'removeconstantrows'
                % Typically strips constant rows during training; at runtime it passes through.
                % Treat as identity for Jacobian in typical cases.
                % If rows were actually removed, net(u) would expect a smaller input → not your setup.
                % Leave z, Jproc unchanged.
            otherwise
                % If you used other processFcns (e.g., 'fixunknowns','mapstd'), add them here similarly.
                warning('Processing function %s not explicitly handled; assuming identity Jacobian.', f);
        end
    end
end

function a = local_act(name, n)
    switch lower(name)
        case {'purelin'}, a = n;
        case {'tansig'},  a = tansig(n);
        case {'logsig'},  a = logsig(n);
        case {'poslin','relu'}, a = max(0,n);
        case {'satlin'},  a = max(0, min(1, n));
        otherwise, error('Unsupported transferFcn: %s', name);
    end
end

function dp = local_act_deriv(name, n, a)
    switch lower(name)
        case {'purelin'}, dp = ones(size(n));
        case {'tansig'},  dp = 1 - a.^2;
        case {'logsig'},  dp = a .* (1 - a);
        case {'poslin','relu'}, dp = double(n > 0);
        case {'satlin'},  dp = double(n > 0 & n < 1);
        otherwise, error('Unsupported transferFcn: %s', name);
    end
end
